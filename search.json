[{"title":"收藏","path":"/2025/02/06/收藏/","content":"记录一些收藏网址 FatfoxTab新标签页 iTab新标签页 showDoc 生成在线API文档 layui框架 JD反编译软件 在线编写代码 layDate - JS日期与时间组件&#x2F;日历插件 (layuiweb.com) 在线PPT转WORD Typora 0.93版本–百度网盘 百度云直链下载-IDM+油猴插件（一）_百度网盘直链下载-CSDN博客 学习正则表达式 https://eladmin.vip/（eladmin脚手架）"},{"title":"鼎捷ERP笔记","path":"/2025/02/06/鼎捷ERP 笔记/","content":"因为鼎捷ERP使用的开发语言为小语种开发语言，此文档记录一些在学习鼎捷ERP开发过程中的知识点，目前可能会有点乱后续再进行整理归纳。 鼎捷ERP笔记r.razzi900新增程序azzi910 新增作业 规格下载规格 迁出程序和规格 (未迁出程序无法上传)复制程序 adzp270下载规格 打开规格(档案 开启档案)上传规格 检查复制过程中的错误下载程序 上传程序 r.t 打开表格设计器 迁出表格 (修改扩展字段名) 执行异动r.q打开开窗设计器开窗识别码 c客制 q标准 cp_字段编辑 说明F双击新增栏位测试开窗 回到规格设置器修高查询时开窗以及comment 上传规格下载程序 上传程度r.v校验带值 cv开头 新增修改表格要异动表格画面生成器 按钮 增加edit空间 修改table代号和字段代号控件代号 表格名.字段名comment后面改成字段名 表头数组命名 g_表格名_m表体 g_表格名_d 接口 azzi700服务规格编号cwssp开头(程序名称)三位流水号接口名称 (ws服务名称)服务类别下载程序 用服务规格编号搜索 在程序开始位置写import util 接口传输以数组形式 json转成数组创建数组 r.d 作业号 操作页面即可debug联络识别码有位数要求 aooi130 建立用户编号azzi800 用户用户资料azzi850 维护角色组资料 azzi920 报错信息编号维护 azzi500 企业编号维护作业 集成接口开发（接收） azzi700注册作业 T100设计器签出和下载程序 T100设计器撰写代码后上传程序 接口测试 集成接口作业开发（推送） azzi901注册推送接口子程序 （规格编号命名规则 cs_fy_send_第三方系统简称） T100设计器签出程序 T100设计器下载程序 Debug watch 用法 （CTRL+D打开） 已知报错信息码 r.d+ 作业号 ctrl+d watch g_errparam.code if g_errparam.code&#x3D;’报错信息码’ T100设计器使用规范首次使用 建立连线方式，站点就是应用服务器的地址，登入区域默认1正式区（有些企业开发人员规定只能在测试区开发，那就填2），账号和密码由公司分配，如果没有就用tiptop ，密码默认也是，工作目录建议放到别的目录，不能带中文 更新基础资料，进阶功能&gt;更新基础数据，等到进度条跑完，提示基础数据完成之后，就完成了设计器的配置了 下载规格和程序，规格就是之前的画面档，在T100叫做规格设计器引入了一个签入签出的概念，程序允许自由下载查看，但是如果要想要修改后上传到服务器，程序必须先签出，如果其他人签出了，则只能等别人签入后，你再进行签出，这个设计的本意是，防止大家调整共同的代码，造成功能混乱，是个很不错的理念，但是如果共用账号的话，比如大家都是用顶呱呱开发的，那就没有意义了因为签出之后，大家都可以进行规格代码上传 设计器使用步骤（以axmt500需要新增一个动作为例）： 规格&gt;下载规格（版本控制）&gt; adzp050&gt;搜索axmt500，签出&gt;下载 程序&gt;下载程序（版本控制）&gt; adzp050&gt;搜索axmt500，签出&gt;下载 同时签出规格和程序，防止其他工程师要调整这个程序，导致两边不同步 如果程序未签出，就会在上方，如果是已签出就会在下方，不管是否签出都可以下载，但是只有签出状态才允许修改代码进行上传（自动编译的） 开启规格档案，档案&gt;开启档案&gt;找到对应的路径，找到axmt500（c）中.tzs（T100的画面档不再是4FD，程序也不再是4GL）&gt;选中开启开启后出现的界面和以前的画面档是一样的，规格调整好之后保存，或者直接上传，会提示是否保存的 规格上传成功后，再重新下载一遍程序，这个就是T100的一个开发特点，代码会根据规格生成相应的代码（前提是section没有修改，也不建议修改） 什么是section？ ​ T100的规格和程序是相呼应的，设计器会根据规格生成标准的程序框架，这个框架是不能修改的，但是会在每个段落预留补充逻辑的地方 debug程序&gt;程序除错，效果等同于linux服务器连线上面的rd xxxx（T100的调试指令），界面和tiptop的调试是一样的 原则上T100设计器基本可以处理开发过程的的大部分调试开发问题，并不需要再去连线的Linux服务器的了 T100开发技巧新增字段 通过（azzi910 作业基本数据维护）作业名查找到规格和程序名称 然后签出，下载，上传程序和规格 r.t 打开表格设计器 迁出表格 (修改扩展字段名) 执行异动 在规格上添加对应字段、修改控件属性 上传程序和规格，如果程序没有解开框架不需要修改程序，如果解开了可以查找CONSTRUCT BY NAME，INPUT BY NAME，b_fill，update和insert语句 进行修改 重新打开作业即可看到效果 改变账套 TOPENT&#x3D;2 定义 DEFINE –定义一个变量（关键字DEFINE）写法1 直接定义类型DEFINE l_ac decimal(5,0) #整数DEFINE l_sql string #文本 写法2 参考数据库的原有数据类型 r.t (关键字LIKE)DEFINE l_ac LIKE type_t.num5 #整数DEFINE l_sql LIKE type_t.chr4000 #文本 –定义数据结构参考类型TYPE type_test RECORD #定义一个参考类型 num1 LIKE type_t.num5, num2 LIKE type_t.num5, num3 LIKE type_t.num5, dat1 LIKE type_t.dat, dat2 LIKE type_t.dat, chr1 LIKE type_t.chr100 END RECORD –定义一个一维数组(单行数据)DEFINE g_test type_test #根据type_test的结构定义一个一维数组 –定义一个二维数组(多行数据)DEFINE g_test1 DYNAMIC ARRAY OF type_test 注意：1.在一个函数内，一个变量只能定义一次，包括头文件和MAIN入口 2.变量使用前，尽量做个初始化，清空原值 3.尽量按照T100程序的变量命名规则去做变量定义，具体可以参考T100的程序 赋值 LET 赋值关键词：LET定义一个文本变量，并赋值为周杰伦：DEFINE l_name LIKE type_t.chr20LET l_name &#x3D; ‘周杰伦’ 定义一个数值变量，并赋值为888:DEFINE l_num LIKE type_t.num10LET l_num &#x3D; 888 另一种赋值的方式：INTO 从数据库取值获取100001料件的单位DEFINE l_imaa006 LIKE imaa_t.imaa006 SELECT imaa006 INTO l_imaa006 FROM imaa_t WHERE imaaent&#x3D;’企业号’ AND imaa001&#x3D; ‘100001’ 提示报错信息(弹框) 1234567INITIALIZE g_errparam TO NULL LET g_errparam.extend = &quot;警告：&quot; #错误信息的前缀LET g_errparam.code = &#x27;aap-00113&#x27; #错误信息代码，在常用工具-&gt;错误讯息维护作业中添加LET g_errparam.popup = FALSE #错误信息是否需要弹框（false不用，true则有）CALL cl_err()NEXT FIELD CURRENT 年龄限制 18~60 12345678910111213141516171819202122cl_null() 用于判断是否为空g_oozyuc_m.oozyuc004 获取表头变量azzi920 错误代码维护，&quot;coo-00666&quot; 是我自定义的错误编号#检查年龄必须 &gt;=18 并且 &lt;=60 IF NOT cl_null(g_oozyuc_m.oozyuc004) THEN IF g_oozyuc_m.oozyuc004 &lt; 18 OR g_oozyuc_m.oozyuc004 &gt; 60 THEN INITIALIZE g_errparam TO NULL LET g_errparam.extend = &quot;&quot; LET g_errparam.code = &quot;coo-00666&quot; LET g_errparam.popup = TRUE CALL cl_err() NEXT FIELD oozyuc004 END IF END IF 报错 代码段：INITIALIZE g_errparam TO NULL LET g_errparam.extend = &quot;&quot;LET g_errparam.code = &quot;coo-00666&quot; #azzi920维护错误码LET g_errparam.popup = TRUE CALL cl_err() 某字段刚开始可编辑修改的，怎么改程序变为不可修改，如果要修改就这张单子作废从源头开始修改 cl_set_comp_visible(“字段名称 “,FALSE) 数据库报错码 -236 sql前后字段数量不一致 -391 向非NULL字段插入NULL值了 -268 违反唯一约束约束名称 T100的报错语法杂记 12345678910111213141516171819202122232425261.1.一般用于编辑新增或者修改的时候，插入数据库段的检查，如果有报错信息，则会INSERT失败。*IF SQLCA.SQLCODE THEN INITIALIZE g_errparam TO NULL LET g_errparam.extend = &quot;wmbcuc_t:&quot;,SQLERRMESSAGE LET g_errparam.code = SQLCA.SQLCODE LET g_errparam.popup = TRUE CALL s_transaction_end(&#x27;N&#x27;,&#x27;0&#x27;) CALL cl_err() CANCEL INSERTELSE*1.2.一般用于栏位输入之后的值的检查，如果有误，则会给出提示并且光标停留在此栏位上*IF l_cntin &lt;= 0 THEN INITIALIZE g_errparam TO NULL LET g_errparam.extend = &quot;输入的车间编号不存在，请检查&quot; LET g_errparam.code = &quot;&quot; #也可以将g_errparam.extend=&quot;&quot;;.code的值在azzi920中维护 LET g_errparam.popup = TRUE CALL cl_err() NEXT FIELD CURRENTEND IF*1.3.使用message弹窗功能，这种方式本人使用的比较少\t上面的内容就是我个人总结的报错语法，报错的语法相对要简单一点，只是经常会用到，所以做个总结，方便以后查看。如有不正确的地方，还请指正，感谢！ 数组下标从1开始 从0开始会调试报错 通过作业编号查找对应的程序 azzi910 作业基本数据维护 点打印报错提示FRIP未在系统参数设置（azzs010）中建制正确信息 lib-0398 错误码 解决办法： azzs010—&gt; 可视化报表-&gt;可视化报表主机网址，例「http:&#x2F;&#x2F;报表主机IP:端口号」 填写帆软报表服务器的地址打开帆软设计器 服务器-&gt; 服务器报表平台管理 开发主程序 开发子程序 复制程序 数据表设计器 r.t 新建表资料 字段数据设计adzi150 开窗设计器r.q-&#x2F;adzi210 校验设计器r.v 画面产生器r.a（adzp168） 常用程序 复制程序与规格：adzp270 设计数据删除工具：adzp063 程序资料过单：adzi888 开发问题点收集 为什么不能新增报错信息 正式区\\测试区 怎么区分 企业编号和据点作用 封装好程序怎么看源代码 怎么开发一个接口和发送接口 这是开启了两个事务，这两个事务是包含关系还是独立关系 怎么通过快速查看整个页面的逻辑 具体到每个字段的逻辑，比如新增单据时经过了每个字段有哪些校验，删除时有哪些校验 为什么有些单据无法搜到规格 类似于g_user 全局变量有哪些 常用字符串解析成对象，对象转成字符串， 怎么调用页面审核接口 SQLCA.sqlcode 常见状态码 怎么主动调用另外一个系统的WebApi 以及web Service ，怎么设置当在页面上触发某个动作时自动调用某个API或者Webservice 大班课培训笔记 123CALL util.JSON.parse( js, cust_rec ) #从JS内把资料取入阵列LET js = util.JSON.stringify( cust_rec ) #从cust_rec 把资料写入JS ERP增加FR报表打印模板 新增程序 新增规格 生成画面 azzi900新增报表程序 azzi910 产生作业 同时签出规格和程序(不要下载) azzi901 注册子程序 签出子程序 报表组件设计器adzp188 复制规格和程序adzp270 作业挂载报表程序azzi988 FR 系统保留模板参数 title1：主标题(通常为公司名称)title2：副标题(通常为报表名称)pdate：制表日期date_fmt：日期格式user：制表人IDuser_name：制表人名称logo：公司Logo档名\u000bfr_sessionid：模板资料集参数使用 fr_timestamp：范本资料集参数使用 常用作业 azzi991 单据别参数维护作业 参数值 aooi200 单据别维护作业 针对某个作业配置参数 员工信息维护 aooi130 ooag_t 部门信息 维护 ooefl_t aoos020 营运据点参数设置","tags":["鼎捷ERP"],"categories":["技术笔记"]},{"title":"开发文档","path":"/2025/02/05/开发文档/","content":"记录日常开发中遇到的问题以及处理办法 开发文档Linux命令chmod 加所有权限 1chmod -R 777 文件名 .开头的文件是隐藏文件查看语言环境，修改语言环境为中文 12echo $LANGexport LANG=zh_CN.UTF-8 mkdir 递归创建文件夹 1mkdir -p 文件夹 touch 创建空文件 1touch 文件名 tree 查看文件夹的树形结构 1tree 文件夹 在文件中搜寻字符串 123grep &quot;2024&quot; *.loggrep -l &quot;2024&quot; *.log 只显示文件名 不显示所有符合条件的位置 一个文件夹可能会存在多个位置符合条件 git解决npm install安装出现packages are looking for funding run npm fund for details问题 1npm config set fund false --location=global 解决：git SSL certificate problem: unable to get local issuer certificate 1git config --global http.sslbackend schannel 解决 坑：ssh: connect to host github.com port 22: Connection refused 排查思路ssh: connect to host github.com port 22: Connection refused这个错误提示的是连接github.com的22端口被拒绝了。 原本以为http://github.com挂了，但是浏览器访问http://github.com一切正常。 网上搜索这个报错，发现很多人遇到这个问题，大概有2个原因和对应解决方案： 使用GitHub的443端口22端口可能被防火墙屏蔽了，可以尝试连接GitHub的443端口。 12345678910$ vim ~/.ssh/config```# Add section below to itHost github.com Hostname ssh.github.com Port 443```$ ssh -T git@github.comHi xxxxx! You&#x27;ve successfully authenticated, but GitHub does notprovide shell access. 这个解决方案的思路是：给~/.ssh/config文件里添加如下内容，这样ssh连接GitHub的时候就会使用443端口。 123Host github.com Hostname ssh.github.com Port 443 如果~/.ssh目录下没有config文件，新建一个即可。 修改完~/.ssh/config文件后，使用ssh -T git@github.com来测试和GitHub的网络通信是否正常，如果提示Hi xxxxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 就表示一切正常了。 但是，这个方案在我这里行不通，修改后还是提示ssh: connect to host github.com port 443: Connection refused。 这个方案有效的前提是：执行命令ssh -T -p 443 git@ssh.github.com后不再提示connection refused，所以要尝试这个方案的小伙伴先执行这条命令测试下。 使用https协议，不要使用ssh协议在你的GitHub的本地repo目录，执行如下命令： 1$ git config --local -e 然后把里面的url配置项从git格式 1url = git@github.com:username/repo.git 修改为https格式 1url = https://github.com/username/repo.git 这个其实修改的是repo根目录下的./git/config文件。 但是这个方法在我这里同样不生效。 解决方案网上的招都没用，只能自力更生了。既然和GitHub建立ssh连接的时候提示connection refused，那我们就详细看看建立ssh连接的过程中发生了什么，可以使用ssh -v命令，-v表示verbose，会打出详细日志。 12345678$ ssh -vT git@github.comOpenSSH_9.0p1, OpenSSL 1.1.1o 3 May 2022debug1: Reading configuration data /etc/ssh/ssh_configdebug1: Connecting to github.com [::1] port 22.debug1: connect to address ::1 port 22: Connection refuseddebug1: Connecting to github.com [127.0.0.1] port 22.debug1: connect to address 127.0.0.1 port 22: Connection refusedssh: connect to host github.com port 22: Connection refused 从上面的信息马上就发现了诡异的地方，连接http://github.com的地址居然是::1和127.0.0.1。前者是IPV6的localhost地址，后者是IPV4的localhost地址。 到这里问题就很明确了，是DNS解析出问题了，导致http://github.com域名被解析成了localhost的ip地址，就自然连不上GitHub了。 Windows下执行ipconfig /flushdns 清楚DNS缓存后也没用，最后修改hosts文件，增加一条github.com的域名映射搞定。 1140.82.113.4 github.com 查找http://github.com的ip地址可以使用https://dnschecker.org/来查询github.com在全球的ip地址，也可以通过 https://api.github.com/meta 查看github.com官方公布的IP地址 这个问题其实就是DNS解析被污染了，有2种可能： DNS解析被运营商劫持了 使用了科学上网工具 按照我上面写的解决方案操作即可解决。 最后大招如果你发现DNS解析并没有解析到127.0.0.1，但是执行ssh -vT git@github.com就是显示当前github.com解析的ip连接22端口和443端口失败，那就直接去https://dnschecker.org/或者https://api.github.com/meta找另外的可用ip。 然后修改自己电脑上的DNS解析host文件，把http://github.com解析到新的ip，然后再测试。 注册github账号失败提示 Unable to verify your captcha response. Please visit https://help.github.com/articles/troubleshooting-connectivity-problems/#troubleshooting-the-captcha for troubleshooting information. 用http://ipaddress.com查 http://octocaptcha.com的地址，在hosts里面补上后又操作了一遍flushdns 140.82.112.4 octocaptcha.com再访问 OctoCaptcha https://octocaptcha.com/ 回头到注册页面重新执行注册动作就会出现验证码 解决hexo d &#x2F; ssh 22端口超时方法 连接超时，首先找到git的安装目录，找到&#x2F;etc&#x2F;ssh&#x2F;ssh_config文件,使用记事本打开它。 把如下内容复制到ssh_config文件的末尾处：并记得保存。 重新尝试 hexo d或者 ssh -T &#x67;&#105;&#116;&#64;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#x2e;&#x63;&#x6f;&#109; 参考链接解决-git连接github超时问题Connection timed out | 浅悦的编程时光 123456Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 hexo 部署后页面显示的内容为main分支而不是master 解决 选择博客所对应的仓库 ，然后选择上面一排选项卡中settings 然后把右边General选项卡中Default Branch 和Page选项卡中Build and deployment 下的branch都改成 master即可 受网络影响可能前面几次刷新看到的效果没有变化 可以多刷新几次试试 笔记源码管理建议使用 GitHub 仓库在前面的步骤中，我们还没有把源码放进仓库中保存，这样会很容易丢失。所以接下来我们再创建一个仓库，例如可以命名为 myblog-source 用来表示这个仓库存放的是源码，这个仓库建议选择为「Private」即私有仓库。 首先把这个仓库克隆到本地： 1git clone https://github.com/username/myblog-source 然后在此仓库中配置一下忽略文件： 12345.DS_Storenode_modulesdb.json.deploy_gitpublic 这些文件可以根据我们的源码生成，所以建议忽略它们，不让版本库追踪这些文件的变化。然后把我们的博客工程目录整个复制进来，或者在这里面重新创建一个，最终 myblog-source 仓库目录结构会是这样的： 12345678910111213myblog-source: - scaffolds: # 模版 - draft.md - page.md - post.md - source: _posts: # 这里面存放文章 - xxx.md - themes: ... - _config.yml # 配置文件 - package.json ... 然后把这些文件提交并推送到 GitHub 上就可以啦： 123git add --allgit commit -m &quot;update&quot;git push origin main 类型转换异常从list中获取的元素如果是map，直接遍历会报类型异常 解决方案： 1、将map转成json，在转成对象（这种方式比较简单，很多json工具方法都有） 2、反序列化成对象 参考 https://blog.csdn.net/weixin_40841731/article/details/89394364 https://blog.csdn.net/LL9504/article/details/106064561 手动回滚事务 例：类似这样的方法不会回滚 （一个方法出错，另一个方法不会回滚） ： 1234567if(userSave)&#123;try &#123;userDao.save(user);userCapabilityQuotaDao.save(capabilityQuota);&#125; catch (Exception e) &#123;logger.info(&quot;能力开通接口，开户异常，异常信息：&quot;+e);&#125; &#125;下面的方法回滚（一个方法出错，另一个方法会回滚）： 123456789if(userSave)&#123;try &#123;userDao.save(user);userCapabilityQuotaDao.save(capabilityQuota);&#125; catch (Exception e) &#123;logger.info(&quot;能力开通接口，开户异常，异常信息：&quot;+e);throw new RuntimeException();&#125;&#125; 或者： 123456789if(userSave)&#123;try &#123;userDao.save(user);userCapabilityQuotaDao.save(capabilityQuota);&#125; catch (Exception e) &#123;logger.info(&quot;能力开通接口，开户异常，异常信息：&quot;+e);TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();&#125;&#125; 参考：Spring事务异常回滚。TransactionAspectSupport（学习理解）_DLTMOLI的博客-CSDN博客 如何修改Oracle中表的字段长度？ 表中已存有数据：ALTER table *tableName MODIFY* (字段名 字段类型(长度)); eg: alter table dpsm_dm_drugslog modify(person VARCHAR2(30)); 表中未存有数据：ALTER TABLE TABLENAME MODIFY ID CHAR（16） eg: alter table dpsm_dm_drugslog modify person VARCHAR2(30); Field获取实体类的属性名和属性值1234567891011121314151617实现步骤获取实体类 返回的是一个数组 数组的数据就是实体类中的字段添加setAccessible（）因为的字段是用private修饰的输出属性名和属性值 User user = new User(); //获取实体类 返回的是一个数组 数组的数据就是实体类中的字段 Field[] fields = user.getClass().getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) &#123; //有的字段是用private修饰的 将他设置为可读 fields[i].setAccessible(true); try &#123; // 输出属性名和属性值 System.out.println(&quot;属性名&quot;+fields[i].getName()+&quot;-----属性值&quot;+fields[i].get(user)); catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; java开发过程中，报错Dangling meta character ‘*’ near index 0，解决办法 1、split方法转化字符串为数组： String[] strPicArr &#x3D; map.get(“hw_pic”).toString().split(“*”); 报错： java.util.regex.PatternSyntaxException: Dangling meta character ‘*’ near index 0 2、经调试跟踪发现字符串中带有“”时，“”分隔字符串成数组是不正确的，正确的写法是： String[] strPicArr &#x3D; map.get(“hw_pic”).toString().split(“\\*”); 修改后，运行正常。 3、因为+、*、|、\\等符号在正则表达示中有相应的不同意义，所以在使用时要进行转义处理。 这里同样可以用 String[] strPicArr &#x3D; map.get(“hw_pic”).toString().split(“[*]”); list 指定字段去重1、使用toCollection和TreeSet去重TreeSet内部使用的是TreeMap，使用指定Comparator比较元素，如果元素相同，则新元素代替旧元素。 123456List&lt;TalentPlanStudentEntity&gt; studentList = relatePlanStudentList.stream() .collect(Collectors.collectingAndThen(Collectors.toCollection( () -&gt; new TreeSet&lt;&gt;(Comparator.comparing(TalentPlanStudentEntity::getUserId))), ArrayList::new)); 2、使用Collectors.toMap去重Collectors.toMap需要使用三个参数的版本，前两个参数一个是keyMapper函数一个是valueMapper函数的，第三个参数BinaryOperator函数接口。BinaryOperator函数接收两个参数，一个oldValue，一个newValue。用于当key重复时的数据处理 12345List&lt;TalentPlanStudentEntity&gt; studentList = new ArrayList&lt;&gt;(relatePlanStudentList.stream() .collect(Collectors.toMap(TalentPlanStudentEntity::getUserId, Function.identity(), (oldValue, newValue) -&gt; oldValue)) .values()); 示例 123456789101112131415List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(&quot;1&quot;,&quot;李大锤&quot;,&quot;23&quot;,&quot;南京&quot;)); userList.add(new User(&quot;2&quot;,&quot;张无忌&quot;,&quot;18&quot;,&quot;西安&quot;)); userList.add(new User(&quot;3&quot;,&quot;刘德华&quot;,&quot;26&quot;,&quot;苏州&quot;)); userList.add(new User(&quot;4&quot;,&quot;郭靖&quot;,&quot;33&quot;,&quot;上海&quot;)); userList.add(new User(&quot;1&quot;,&quot;李大锤&quot;,&quot;23&quot;,&quot;南京&quot;)); //id相同，其他数据也相同 userList.add(new User(&quot;3&quot;,&quot;带头大哥&quot;,&quot;36&quot;,&quot;杭州&quot;)); //id相同，其他数据不同 System.out.println(userList); //根据userid去重 userList = userList.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(User :: getUserid))), ArrayList::new)); java添加图片到Excel单元格中(POI) http://t.csdn.cn/12Plg 当查询的数据集为空时需要显示指定内容123456UNION (SELECT\t-1 rn,\tNULL,NULL FROM\tdual) https://blog.csdn.net/oREEFE/article/details/111401742 多个like解决方案 多个like 12345678SELECT\ttitleFROM\ttestWHERE\tregexp_like(TITLE,&#x27;(150|160|85|16|1x|23|002|x2|99|98)$&#x27;) not\tregexp_like(TITLE,&#x27;(150|160|85|16|1x|23|002|x2|99|98)$&#x27;) https://blog.csdn.net/qq_41655648/article/details/90512281 Linux 删除包含指定字符的文件夹1find . -name &quot;file_name*&quot;|xargs rm -rfv 错误：Attempted read from closed stream尝试读取关闭的流！！！ 原因：一个HttpClient里只能有一次获取Entity的操作，不能有多次获取Entity的操作，getEntity()获取的流是一次性的，用了一次就会自动关闭，第二次调用的时候就是调一个关闭的流，就会抛出：Attempted read from closed stream; 解决办法：如果一个方法只对同一个Entity操作，可以用BufferedHttpEntity，可以多次读取流！原文链接：https://blog.csdn.net/QQ_hoverer/article/details/117667065 123456789101112HttpEntity entity = httpResponse.getEntity(); if (!Objects.isNull(entity)) &#123; try &#123; //entity实体流保存缓冲区,否则只能操作一次流就会关闭 ,BufferedHttpEntity可以多次读取流 entity = new BufferedHttpEntity(entity); responseBody = URLEncodedUtils.parse(entity).toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); LogUtils.error(e, log, &quot;io转换错误&quot;); &#125; &#125; Java：根据List中的对象的某个属性：求和、最大、最小、平均值。（用Stream）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//实体类public class Student &#123; private int mathScoresInt; //数学成绩 private long mathScoresLong;//数学成绩 private float mathScoresFloat;//数学成绩 private double mathScoresDouble;//数学成绩 private BigDecimal mathScoresBigDecimal;//数学成绩 //构造方法忽略 //set、get 方法忽略&#125;//测试数据 ( 不允许list中存在为空的值，不然会异常! )List&lt;Student&gt; list = new ArrayList();list.add(new Student(87, 87, 87.5f, 87.8, new BigDecimal(87)));list.add(new Student(88, 88, 88.5f, 88.8, new BigDecimal(88)));list.add(new Student(89, 89, 89.5f, 89.8, new BigDecimal(89)));list.add(new Student(90, 90, 90.5f, 90.8, new BigDecimal(90)));//提示：以下计算为int 、long 、float 、double 、BigDecimal 等类型//一、根据List中的对象的某个属性，求和 int mathSumInt = list.stream().mapToInt( Student::getMathScoresInt ).sum(); //int类型 long mathSumLong = list.stream().mapToLong( Student::getMathScoresLong ).sum(); //long类型 double mathSumDouble = list.stream().mapToDouble( Student::getMathScoresDouble ).sum(); //double类型 BigDecimal mathSumBigDecimal = list.stream().map( Student::getMathScoresBigDecimal ).reduce(BigDecimal.ZERO, BigDecimal::add); //BigDecimal类型//二、根据List中的对象的某个属性，求平均值double mathAverageInt = list.stream().mapToInt( Student::getMathScoresInt ).average().orElse(0d);double mathAverageLong = list.stream().mapToLong( Student::getMathScoresLong ).average().orElse(0d);double mathAverageDouble = list.stream().mapToDouble( Student::getMathScoresDouble ).average().orElse(0d);BigDecimal averageBigDecimal = list.stream().map(Student::getMathScoresBigDecimal).reduce(BigDecimal.ZERO, BigDecimal::add).divide(BigDecimal.valueOf(list.size()), 2, RoundingMode.HALF_UP);//三、根据List中的对象的某个属性，求最大值int mathMaxInt = list.stream().mapToInt( Student::getMathScoresInt ).max().getAsInt(); //int类型long mathMaxLong = list.stream().mapToLong( Student::getMathScoresLong ).max().getAsLong();double mathMaxDouble = list.stream().mapToDouble( Student::getMathScoresDouble ).max().getAsDouble();//BigDecimal推荐用这种BigDecimal mathMinBigDecimal = list.stream().map( Student::getMathScoresBigDecimal ).max(BigDecimal::compareTo).get();//全是负数时，这种比较结果，会有错误，最大值恒等于0BigDecimal mathMaxBigDecimal2 = list.stream().map( Student::getMathScoresBigDecimal ).reduce(BigDecimal.ZERO, BigDecimal::max);//四、根据List中的对象的某个属性，求最小值int mathMinInt = list.stream().mapToInt( Student::getMathScoresInt ).min().getAsInt();long mathMinLong = list.stream().mapToLong( Student::getMathScoresLong ).min().getAsLong();double mathMinDouble = list.stream().mapToDouble( Student::getMathScoresDouble ).min().getAsDouble();//BigDecimal推荐用这种BigDecimal mathMinBigDecimal = list.stream().map( Student::getMathScoresBigDecimal ).max(BigDecimal::compareTo).get();//全是正数时，这种比较结果，会有错误，最小值恒等于0BigDecimal mathMinBigDecimal2 = list.stream().map( Student::getMathScoresBigDecimal ).reduce(BigDecimal.ZERO, BigDecimal::min);//五、根据List中的对象的某个属性，找出最大N个对象/最小N个对解题思路：把list集合，按照某个属性升序/降序，再取N个对象//将List转换List 【不过滤，不去重，升序，取有限数】 (本案例：取年龄最小2位)List&lt;Student&gt; studentList = list.stream().sorted(Comparator.comparing(Student::getAge)).limit(2).collect(Collectors.toList());//将List转换List 【不过滤，不去重，降序，取有限数】 (本案例：取年龄最大2位)List&lt;Student&gt; studentList =\tlist.stream().sorted(Comparator.comparing(Student::getAge).reversed()).limit(2).collect(Collectors.toList()) 数字转大写汉字 JAVA123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404package cn.hutool.core.convert;import cn.hutool.core.util.ArrayUtil;import cn.hutool.core.util.StrUtil;/** * 数字转中文类 **/public class NumberChineseFormatterUtils &#123;\t/** * 中文形式，奇数位置是简体，偶数位置是记账繁体，0共用 * 使用混合数组提高效率和数组复用 **/\tprivate static final char[] DIGITS = &#123;&#x27;零&#x27;, &#x27;一&#x27;, &#x27;壹&#x27;, &#x27;二&#x27;, &#x27;贰&#x27;, &#x27;三&#x27;, &#x27;叁&#x27;, &#x27;四&#x27;, &#x27;肆&#x27;, &#x27;五&#x27;, &#x27;伍&#x27;, &#x27;六&#x27;, &#x27;陆&#x27;, &#x27;七&#x27;, &#x27;柒&#x27;, &#x27;八&#x27;, &#x27;捌&#x27;, &#x27;九&#x27;, &#x27;玖&#x27;&#125;;\t/** * 汉字转阿拉伯数字的 */\tprivate static final ChineseUnit[] CHINESE_NAME_VALUE = &#123; new ChineseUnit(&#x27; &#x27;, 1, false), new ChineseUnit(&#x27;十&#x27;, 10, false), new ChineseUnit(&#x27;拾&#x27;, 10, false), new ChineseUnit(&#x27;百&#x27;, 100, false), new ChineseUnit(&#x27;佰&#x27;, 100, false), new ChineseUnit(&#x27;千&#x27;, 1000, false), new ChineseUnit(&#x27;仟&#x27;, 1000, false), new ChineseUnit(&#x27;万&#x27;, 1_0000, true), new ChineseUnit(&#x27;亿&#x27;, 1_0000_0000, true),\t&#125;;\t/** * 阿拉伯数字转换成中文,小数点后四舍五入保留两位. 使用于整数、小数的转换. * * @param amount 数字 * @param isUseTraditional 是否使用繁体 * @return 中文 */\tpublic static String format(double amount, boolean isUseTraditional) &#123; return format(amount, isUseTraditional, false);\t&#125;\t/** * 阿拉伯数字转换成中文,小数点后四舍五入保留两位. 使用于整数、小数的转换. * * @param amount 数字 * @param isUseTraditional 是否使用繁体 * @param isMoneyMode 是否为金额模式 * @return 中文 */\tpublic static String format(double amount, boolean isUseTraditional, boolean isMoneyMode) &#123; if (amount &gt; 99_9999_9999_9999.99 || amount &lt; -99999999999999.99) &#123; throw new IllegalArgumentException(&quot;Number support only: (-99999999999999.99 ～ 99999999999999.99)！&quot;); &#125; // 负数 boolean negative = false; if (amount &lt; 0) &#123; negative = true; amount = -amount; &#125; // 分和角 long temp = Math.round(amount * 100); final int numFen = (int) (temp % 10); temp = temp / 10; final int numJiao = (int) (temp % 10); temp = temp / 10; final StringBuilder chineseStr = new StringBuilder(longToChinese(temp, isUseTraditional)); //负数 if (negative) &#123; // 整数部分不为 0 chineseStr.insert(0, &quot;负&quot;); &#125; // 小数部分 if (numFen != 0 || numJiao != 0) &#123; if (numFen == 0) &#123; chineseStr.append(isMoneyMode ? &quot;元&quot; : &quot;点&quot;).append(numberToChinese(numJiao, isUseTraditional)).append(isMoneyMode ? &quot;角&quot; : &quot;&quot;); &#125; else &#123; // “分”数不为 0 if (numJiao == 0) &#123; chineseStr.append(isMoneyMode ? &quot;元零&quot; : &quot;点零&quot;).append(numberToChinese(numFen, isUseTraditional)).append(isMoneyMode ? &quot;分&quot; : &quot;&quot;); &#125; else &#123; chineseStr.append(isMoneyMode ? &quot;元&quot; : &quot;点&quot;).append(numberToChinese(numJiao, isUseTraditional)).append(isMoneyMode ? &quot;角&quot; : &quot;&quot;).append(numberToChinese(numFen, isUseTraditional)).append(isMoneyMode ? &quot;分&quot; : &quot;&quot;); &#125; &#125; &#125; else if (isMoneyMode) &#123; //无小数部分的金额结尾 chineseStr.append(&quot;元整&quot;); &#125; return chineseStr.toString();\t&#125;\t/** * 数字字符转中文，非数字字符原样返回 * * @param c 数字字符 * @param isUseTraditional 是否繁体 * @return 中文字符 * @since 5.3.9 */\tpublic static String numberCharToChinese(char c, boolean isUseTraditional) &#123; if (c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; return String.valueOf(c); &#125; return String.valueOf(numberToChinese(c - &#x27;0&#x27;, isUseTraditional));\t&#125;\t/** * 阿拉伯数字整数部分转换成中文，只支持正数 * * @param amount 数字 * @param isUseTraditional 是否使用繁体 * @return 中文 */\tprivate static String longToChinese(long amount, boolean isUseTraditional) &#123; if(0 == amount)&#123; return &quot;零&quot;; &#125; //将数字以万为单位分为多份 int[] parts = new int[4]; for (int i = 0; amount != 0; i++) &#123; parts[i] = (int) (amount % 10000); amount = amount / 10000; &#125; final StringBuilder chineseStr = new StringBuilder(); int partValue; String partChinese; // 千 partValue = parts[0]; if(partValue &gt; 0)&#123; partChinese = thousandToChinese(partValue, isUseTraditional); chineseStr.insert(0, partChinese); if(partValue &lt; 1000)&#123; // 和万位之间空0，则补零，如一万零三百 addPreZero(chineseStr); &#125; &#125; // 万 partValue = parts[1]; if(partValue &gt; 0)&#123; if((partValue % 10 == 0 &amp;&amp; parts[0] &gt; 0))&#123; // 如果&quot;万&quot;的个位是0，则补零，如十万零八千 addPreZero(chineseStr); &#125; partChinese = thousandToChinese(partValue, isUseTraditional); chineseStr.insert(0, partChinese + &quot;万&quot;); if(partValue &lt; 1000)&#123; // 和亿位之间空0，则补零，如一亿零三百万 addPreZero(chineseStr); &#125; &#125; else&#123; addPreZero(chineseStr); &#125; // 亿 partValue = parts[2]; if(partValue &gt; 0)&#123; if((partValue % 10 == 0 &amp;&amp; parts[1] &gt; 0))&#123; // 如果&quot;万&quot;的个位是0，则补零，如十万零八千 addPreZero(chineseStr); &#125; partChinese = thousandToChinese(partValue, isUseTraditional); chineseStr.insert(0, partChinese + &quot;亿&quot;); if(partValue &lt; 1000)&#123; // 和万亿位之间空0，则补零，如一万亿零三百亿 addPreZero(chineseStr); &#125; &#125; else&#123; addPreZero(chineseStr); &#125; // 万亿 partValue = parts[3]; if(partValue &gt; 0)&#123; if(parts[2] == 0)&#123; chineseStr.insert(0, &quot;亿&quot;); &#125; partChinese = thousandToChinese(partValue, isUseTraditional); chineseStr.insert(0, partChinese + &quot;万&quot;); &#125; if(StrUtil.isNotEmpty(chineseStr) &amp;&amp; &#x27;零&#x27; == chineseStr.charAt(0))&#123; return chineseStr.substring(1); &#125; return chineseStr.toString();\t&#125;\t/** * 把一个 0~9999 之间的整数转换为汉字的字符串，如果是 0 则返回 &quot;&quot; * * @param amountPart 数字部分 * @param isUseTraditional 是否使用繁体单位 * @return 转换后的汉字 */\tprivate static String thousandToChinese(int amountPart, boolean isUseTraditional) &#123; int temp = amountPart; StringBuilder chineseStr = new StringBuilder(); boolean lastIsZero = true; // 在从低位往高位循环时，记录上一位数字是不是 0 for (int i = 0; temp &gt; 0; i++) &#123; int digit = temp % 10; if (digit == 0) &#123; // 取到的数字为 0 if (false == lastIsZero) &#123; // 前一个数字不是 0，则在当前汉字串前加“零”字; chineseStr.insert(0, &quot;零&quot;); &#125; lastIsZero = true; &#125; else &#123; // 取到的数字不是 0 chineseStr.insert(0, numberToChinese(digit, isUseTraditional) + getUnitName(i, isUseTraditional)); lastIsZero = false; &#125; temp = temp / 10; &#125; return chineseStr.toString();\t&#125;\t/** * 把中文转换为数字 如 二百二十 220 * * 一百一十二 -》 112 * 一千零一十二 -》 1012 * * @param chinese 中文字符 * @return 数字 */\tpublic static int chineseToNumber(String chinese) &#123; final int length = chinese.length(); int result = 0; // 节总和 int section = 0; int number = 0; ChineseUnit unit = null; char c; for (int i = 0; i &lt; length; i++) &#123; c = chinese.charAt(i); final int num = chineseToNumber(c); if (num &gt;= 0) &#123; if (num == 0) &#123; // 遇到零时节结束，权位失效，比如两万二零一十 if (number &gt; 0 &amp;&amp; null != unit) &#123; section += number * (unit.value / 10); &#125; unit = null; &#125; else if (number &gt; 0) &#123; // 多个数字同时出现，报错 throw new IllegalArgumentException(StrUtil.format(&quot;Bad number &#x27;&#123;&#125;&#123;&#125;&#x27; at: &#123;&#125;&quot;, chinese.charAt(i - 1), c, i)); &#125; // 普通数字 number = num; &#125; else &#123; unit = chineseToUnit(c); if (null == unit) &#123; // 出现非法字符 throw new IllegalArgumentException(StrUtil.format(&quot;Unknown unit &#x27;&#123;&#125;&#x27; at: &#123;&#125;&quot;, c, i)); &#125; //单位 if (unit.secUnit) &#123; // 节单位，按照节求和 section = (section + number) * unit.value; result += section; section = 0; &#125; else &#123; // 非节单位，和单位前的单数字组合为值 int unitNumber = number; if(0 == number &amp;&amp; 0 == i)&#123; // issue#1726，对于单位开头的数组，默认赋予1 // 十二 -&gt; 一十二 // 百二 -&gt; 一百二 unitNumber = 1; &#125; section += (unitNumber * unit.value); &#125; number = 0; &#125; &#125; if (number &gt; 0 &amp;&amp; null != unit) &#123; number = number * (unit.value / 10); &#125; return result + section + number;\t&#125;\t/** * 查找对应的权对象 * * @param chinese 中文权位名 * @return 权对象 */\tprivate static ChineseUnit chineseToUnit(char chinese) &#123; for (ChineseUnit chineseNameValue : CHINESE_NAME_VALUE) &#123; if (chineseNameValue.name == chinese) &#123; return chineseNameValue; &#125; &#125; return null;\t&#125;\t/** * 将汉字单个数字转换为int类型数字 * * @param chinese 汉字数字，支持简体和繁体 * @return 数字，-1表示未找到 */\tprivate static int chineseToNumber(char chinese) &#123; if (&#x27;两&#x27; == chinese) &#123; // 口语纠正 chinese = &#x27;二&#x27;; &#125; final int i = ArrayUtil.indexOf(DIGITS, chinese); if (i &gt; 0) &#123; return (i + 1) / 2; &#125; return i;\t&#125;\t/** * 单个数字转汉字 * * @param number 数字 * @param isUseTraditional 是否使用繁体 * @return 汉字 */\tprivate static char numberToChinese(int number, boolean isUseTraditional) &#123; if (0 == number) &#123; return DIGITS[0]; &#125; return DIGITS[number * 2 - (isUseTraditional ? 0 : 1)];\t&#125;\t/** * 获取对应级别的单位 * * @param index 级别，0表示各位，1表示十位，2表示百位，以此类推 * @param isUseTraditional 是否使用繁体 * @return 单位 */\tprivate static String getUnitName(int index, boolean isUseTraditional) &#123; if (0 == index) &#123; return StrUtil.EMPTY; &#125; return String.valueOf(CHINESE_NAME_VALUE[index * 2 - (isUseTraditional ? 0 : 1)].name);\t&#125;\t/** * 权位 */\tprivate static class ChineseUnit &#123; /** * 中文权名称 */ private final char name; /** * 10的倍数值 */ private final int value; /** * 是否为节权位，它不是与之相邻的数字的倍数，而是整个小节的倍数。&lt;br&gt; * 例如二十三万，万是节权位，与三无关，而和二十三关联 */ private final boolean secUnit; /** * 构造 * * @param name 名称 * @param value 值，即10的倍数 * @param secUnit 是否为节权位 */ public ChineseUnit(char name, int value, boolean secUnit) &#123; this.name = name; this.value = value; this.secUnit = secUnit; &#125;\t&#125;\tprivate static void addPreZero(StringBuilder chineseStr)&#123; if(StrUtil.isEmpty(chineseStr))&#123; return; &#125; final char c = chineseStr.charAt(0); if(&#x27;零&#x27; != c)&#123; chineseStr.insert(0, &#x27;零&#x27;); &#125;\t&#125;&#125; 使用TortoiseSVN回滚版本 离开eclipse ，来到要回撤版本的文件夹下，team-&gt;show log（显示日志）右击某个记录回撤版本,然后再重新提交即可。 详情请参考 https://blog.csdn.net/counsellor/article/details/95181981 右击要回滚的文件或文件夹, TortoiseSVN -&gt; Show log, 如下图: 选择你要恢复到(revert)的版本。我这里直接要全部回滚到某个版本就是用了Revert to this revision. 如果你想撤销(undo)一个段版本范围，选择第一个，按住Shift键选中最后一个。如果需要选择一些分离的版本，请使用Ctrl键。右击被选中的版本，选择Context Menu -&gt; Revert Changes from this revision.这两种的区别是第一个很彻底，第二种只修改选中的部分。 现在的文件已经revert(恢复)成了你想要的历史状态，commit即可。 查询锁表SQL1234 SELECT SESS.SID, SESS.SERIAL#, LO.ORACLE_USERNAME, LO.OS_USER_NAME, AO.OBJECT_NAME 被锁对象名, LO.LOCKED_MODE 锁模式, sess.LOGON_TIME 登录数据库时间,&#x27;ALTER SYSTEM KILL SESSION &#x27;&#x27;&#x27; || SESS.SID || &#x27;,&#x27;||SESS.SERIAL#||&#x27;&#x27;&#x27;;&#x27; FREESQLFROM V$LOCKED_OBJECT LO, DBA_OBJECTS AO, V$SESSION SESS WHERE AO.OBJECT_ID = LO.OBJECT_ID AND LO.SESSION_ID = SESS.SID ORDER BY sid, sess.serial#;"},{"title":"Hello World","path":"/2025/02/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]